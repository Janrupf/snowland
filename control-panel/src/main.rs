mod com;
mod ipc;
mod util;

pub use snowland_control_panel_macro as mcr;

use crate::com::{DartToNativeChannel, IpcDisplayEventChannel, IpcStateEventChannel};
use crate::ipc::IPCHandle;
use nativeshell::shell::ContextOptions;
use nativeshell::Context;

nativeshell::include_flutter_plugins!();

/// Data passed to flutter using the window init data functionality.
#[derive(serde::Serialize)]
struct InitData {
    version_major: &'static str,
    version_minor: &'static str,
    version_patch: &'static str,
}

impl InitData {
    /// Collects the data.
    pub fn collect() -> Self {
        Self {
            version_major: env!("CARGO_PKG_VERSION_MAJOR"),
            version_minor: env!("CARGO_PKG_VERSION_MINOR"),
            version_patch: env!("CARGO_PKG_VERSION_PATCH"),
        }
    }
}

/// Normal rust entrypoint, this does some minimal bootstrapping before handing over to flutter.
///
/// In the Snowland control panel Rust is used to build the backend infrastructure and handle low
/// level communication. Frontend and application logic is driven using flutter.
fn main() {
    pretty_env_logger::init();
    log::info!("Starting snowland control panel...");

    // Set up a context for flutter
    let context = match Context::new(ContextOptions {
        app_namespace: "snowland_control_panel".into(),
        flutter_plugins: flutter_get_plugins(), // generated by the include_flutter_plugins! macro
        ..Default::default()
    }) {
        Ok(v) => v,
        Err(err) => {
            log::error!("Failed to create flutter context: {}", err);
            std::process::exit(1);
        }
    };

    /* This part is a bit confusing - we need to create a window, which will then be used as the
     * **main** window in flutter.
     *
     * Later on flutter may create additional windows without us having to handle that manually, as
     * nativeshell does that internally.
     *
     * We also use this opportunity to pass some data to the flutter application.
     */
    let init_data = InitData::collect();

    if let Err(err) = context
        .window_manager
        .borrow_mut()
        .create_window(util::reserialize(init_data).unwrap(), None)
    {
        log::error!("Failed to create main window: {}", err);
        std::process::exit(1);
    }

    // Create the ipc setup
    let mut ipc_handle = IPCHandle::new(context.run_loop.borrow().new_sender());

    // We also need to register some communication channels with dart
    log::debug!("Registering method channels...");
    let _dart_to_native = DartToNativeChannel::register(&context, ipc_handle.clone());
    let _ipc_state_event = IpcStateEventChannel::register(&context, ipc_handle.clone());
    let _display_change_event = IpcDisplayEventChannel::register(&context, ipc_handle.clone());

    // Setup is done, we can now start the application run loop (and thus basically hand of control
    // to flutter)
    log::debug!("Starting run loop...");
    context.run_loop.borrow().run();

    // Reaching this point means the flutter main window was closed. We can do some cleanup here
    log::info!("Snowland control panel shutting down!");

    // Terminate the IPC
    ipc_handle.shutdown();
}
